# Auto Planner (MVP)

Версия: 0.1 (13.11.2025)

## 1. Входные данные

- `stage_option_id` + выбранная доза/метод.
- Прогноз погоды (hourly) на 72 ч вперёд, включая: температура, осадки, ветер, влажность, освещённость (рассвет/закат).
- Контекст объекта: регион, таймзона, занятые окна (events.status in ['scheduled','done']).
- Конфигурация из ENV: `AUTOPLAN_MIN_HOURS_AHEAD`, `WEATHER_PROVIDER`, дефолтные ограничения.

## 2. DSL ограничений

Каждый вариант может задать набор правил:

```json
{
  "weather": {
    "no_rain_hours_before": 2,
    "no_rain_hours_after": 6,
    "wind_max_m_s": 5,
    "wind_min_m_s": 0,
    "temp_min_c": 10,
    "temp_max_c": 25,
    "daylight_only": true
  },
  "calendar": {
    "earliest_date": "2025-04-10",
    "latest_date": "2025-04-25",
    "crop_phase": "до цветения"
  },
  "operational": {
    "duration_min": 60,
    "buffer_min": 30
  },
  "phi_days": 7
}
```

- `no_rain_hours_before/after` проверяются по интенсивности осадков (мм/ч). `<= 0.2` считается сухо.
- `wind_max_m_s` и `temp_*` берутся из усреднённых значений за интервал.
- `daylight_only` — окно должно находиться между `sunrise+30` и `sunset-30`.
- `duration_min` определяет длину слота; `buffer_min` добавляется при переносе событий.

## 3. Алгоритм

1. Стартовое время = `now + AUTOPLAN_MIN_HOURS_AHEAD`.
2. Горизонт = 72 часа, шаг = 30 минут. Слайдинг-окном формируем кандидатов `slot = [t, t + duration]`.
3. Для каждого слота:
   - Проверяем погодные ограничения (до/после дождя, ветер, температура).
   - Учитываем `calendar` (например, не позже `latest_date`).
   - Проверяем конфликты с существующими событиями пользователя (нет пересечений по времени).
   - Валидируем PHI: `slot_start + phi_days` не должен пересекаться с датой сбора (если она задана).
4. Вычисляем `score`:
   - +50 если окно попадает в вечернее время (18:00–22:00) и пользователь часто выбирал вечер.
   - +30 если окно ≥ 12 ч от текущего времени (запас на подготовку).
   - −20 за температуру ближе к границам допустимого диапазона.
   - −30 если накануне уже была обработка (анти-дребезг).
5. Выбираем первый слот с `score >= threshold` (по умолчанию 0). Если ничего не найдено — статус `awaiting_window`.

## 4. Состояния

- `pending` — запуск в очереди.
- `window_found` — слот подобран, записан в `treatment_slots` и `events`.
- `awaiting_window` — нет доступных окон; воркер подписывается на обновление прогноза.
- `failed` — ошибка данных (например, нет прогноза).

При `awaiting_window` воркер повторно запускается по cron или при появлении нового прогноза (webhook `forecast.updated`).

## 5. Reason/Explanation

- Для каждого слота формируется `reason` — массив правил, которые повлияли на решение:
```json
[
  "без осадков с 15:00 до 23:00",
  "ветер 3 м/с (<5)",
  "температура 12–14 °C",
  "дневное окно (17:00–18:00)"
]
```
- `reason` показывается пользователю в карточке предпросмотра и сохраняется в `events.reason`.

## 6. Повторные вычисления

- Изменение прогноза → инвалидация слота (если новые данные нарушают условия) → статус события `needs_reschedule`.
- Пользователь может вручную зафиксировать окно; тогда слот получает `status=accepted` и больше не пересчитывается.
- Команда «Сделать вручную» переводит план в ручной режим (автоплан отключается для выбранных этапов).
